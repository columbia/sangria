use maplit::hashmap;
use once_cell::sync::Lazy;
use std::collections::HashMap;

pub static LABELED_HISTOGRAMS: Lazy<Vec<(i64, HashMap<i64, f64>)>> = Lazy::new(|| {
    vec![
        (
            1,
            hashmap! {
                0 => 1.0,
            },
        ),
        (
            5,
            hashmap! {
                0 => 0.9486530929686167,
                1 => 0.04793601366955254,
                2 => 0.003282050872809248,
                3 => 0.000128842489021458,
            },
        ),
        (
            10,
            hashmap! {
                0 => 0.8958388114184279,
                1 => 0.08599978884538442,
                2 => 0.015492723526194992,
                3 => 0.002247423457138644,
                4 => 0.00034826005212390196,
                5 => 7.2992700729926e-05,
            },
        ),
        (
            25,
            hashmap! {
                0 => 0.7612635564103816,
                1 => 0.1583926699515774,
                2 => 0.05629985023990934,
                3 => 0.018639344363784914,
                4 => 0.0043219961164707,
                5 => 0.00093659751641601,
                6 => 0.000145985401459852,
            },
        ),
        (
            50,
            hashmap! {
                0 => 0.60978228174311,
                1 => 0.2043872103340004,
                2 => 0.11066086747881368,
                3 => 0.04754248618418723,
                4 => 0.019038235268586272,
                5 => 0.00648260413610804,
                6 => 0.001676835222512296,
                7 => 0.000210501530492112,
                8 => 0.000145985401459854,
                9 => 7.2992700729926e-05,
            },
        ),
        (
            100,
            hashmap! {
                0 => 0.4242505523499917,
                1 => 0.21300120629023095,
                2 => 0.14325059047493446,
                3 => 0.09966485604327532,
                4 => 0.06067822291430661,
                5 => 0.03358648807433206,
                6 => 0.015726523441591672,
                7 => 0.006671391905815902,
                8 => 0.0022225988345706098,
                9 => 0.000672339982118038,
                10 => 0.000275229688832336,
            },
        ),
        (
            200,
            hashmap! {
                0 => 0.24999928514284148,
                1 => 0.1717101863117417,
                2 => 0.1307063009146631,
                3 => 0.11487863871271492,
                4 => 0.10002013721857733,
                5 => 0.08050039175768882,
                6 => 0.06011438199924563,
                7 => 0.04099087254165537,
                8 => 0.023897954459798604,
                9 => 0.014144046684405345,
                10 => 0.007331443159639101,
                11 => 0.003694081975558552,
                12 => 0.001434886956810182,
                13 => 0.000511602690975224,
                14 => 6.578947368421e-05,
            },
        ),
        (
            500,
            hashmap! {
                0 => 0.22312008346200934,
                1 => 0.13626746592431294,
                2 => 0.10420359563053692,
                3 => 0.09227924596714585,
                4 => 0.08199742794066033,
                5 => 0.07114414957270548,
                6 => 0.05690617160956678,
                7 => 0.04238342609928486,
                8 => 0.031678507068459864,
                9 => 0.022526348388194686,
                10 => 0.017659334843791643,
                11 => 0.011470400137419838,
                12 => 0.008887213860785989,
                13 => 0.007338308074810607,
                14 => 0.0058941710129466396,
                15 => 0.004662640341732654,
                16 => 0.00410868592193624,
                17 => 0.00448798343707741,
                18 => 0.003828633714214894,
                19 => 0.0029311557211509098,
                20 => 0.0026542067572552317,
            },
        ),
    ]
});

fn euclidean_distance(base: &HashMap<i64, f64>, other: &HashMap<i64, f64>) -> f64 {
    let mut distance = 0.0;

    // Union of keys from both histograms
    let all_keys: std::collections::HashSet<_> = base.keys().chain(other.keys()).copied().collect();

    for key in all_keys {
        let base_val = *base.get(&key).unwrap_or(&0.0);
        let other_val = *other.get(&key).unwrap_or(&0.0);
        distance += (base_val - other_val).powi(2);
    }

    distance.sqrt()
}

pub fn find_closest_label(
    waiters_and_pending_histogram: &HashMap<i64, f64>,
    total_waiters_and_pending: i64,
) -> Option<i64> {
    let normalized_histogram = waiters_and_pending_histogram
        .iter()
        .map(|(k, v)| (*k, *v / total_waiters_and_pending as f64))
        .collect();
    LABELED_HISTOGRAMS
        .iter()
        .map(|(label, hist)| (*label, euclidean_distance(&normalized_histogram, hist)))
        .min_by(|a, b| a.1.partial_cmp(&b.1).unwrap())
        .map(|(label, _)| label)
}

pub fn compute_entropy(
    waiters_and_pending_histogram: &HashMap<i64, f64>,
    total_waiters_and_pending: i64,
) -> f64 {
    let mut entropy = 0.0;
    for (k, v) in waiters_and_pending_histogram {
        let p = *v / total_waiters_and_pending as f64;
        entropy -= p * p.ln();
    }
    entropy
}
